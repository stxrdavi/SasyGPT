<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SasyGPT v3.5 - Liquid Glass Dark Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          // Palette scura e accentata
          colors: {
            'bg-dark': '#0F172A', // Sfondo molto scuro (Slate-900)
            'bg-glass': 'rgba(30, 41, 59, 0.6)', // Base per il vetro (Slate-800 con trasparenza)
            'accent': '#8B5CF6', // Viola brillante (Violet-500)
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'Arial'],
          },
        }
      }
    }
  </script>
  <style>
    /* ----------------------------------- */
    /* STILI CORE GLASSMORPHISM / DARK MODE */
    /* ----------------------------------- */
    body {
      background-color: #0F172A; /* Slate-900 */
      color: #E2E8F0; /* Slate-200 */
      font-family: 'Inter', system-ui, Arial;
    }
    
    /* Card/Container Principale (Liquid Glass) */
    .glass-card {
        background: var(--tw-colors-bg-glass); 
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border: 1px solid rgba(255, 255, 255, 0.1); /* Bordo sottile di luce */
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        border-radius: 24px;
        transition: all 0.3s ease;
    }

    /* Pulsante Standard (Glassy) */
    .glass-button {
        background: rgba(255, 255, 255, 0.1); 
        border: 1px solid rgba(255, 255, 255, 0.15);
        transition: all 0.2s;
    }
    .glass-button:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    .glass-button:active {
        background: rgba(0, 0, 0, 0.2);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        transform: scale(0.98);
    }

    /* Pulsante Accent (Send/Mic) - Pieno per contrasto */
    .glass-accent-btn {
        background-color: var(--tw-colors-accent); 
        color: white;
        box-shadow: 0 4px 15px var(--tw-colors-accent);
        transition: all 0.2s;
    }
    .glass-accent-btn:active {
        background-color: #6D28D9; /* Viola pi√π scuro al click */
        box-shadow: 0 0 5px var(--tw-colors-accent);
        transform: scale(0.98);
    }

    /* Input/Textarea */
    .glass-input {
        background: rgba(0, 0, 0, 0.3); /* Base scura per l'input */
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        transition: border-color 0.2s;
    }
    .glass-input:focus {
        border-color: var(--tw-colors-accent);
        background: rgba(0, 0, 0, 0.4);
    }

    /* Messaggi */
    .msg.bot {
      background: rgba(30, 41, 59, 0.8); /* Bot: leggermente pi√π opaco */
      border: 1px solid rgba(255, 255, 255, 0.05);
      color: #E2E8F0;
    }
    .msg.user {
      background: rgba(139, 92, 246, 0.8); /* User: Viola accentato */
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Scrollbar invisibile */
    .messages::-webkit-scrollbar { display: none; }
    .messages { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Animazione Microfono */
    .mic-listening {
      animation: pulse-mic 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
      box-shadow: 0 0 25px var(--tw-colors-accent) !important;
    }
    @keyframes pulse-mic {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.9; }
      100% { transform: scale(1); opacity: 1; }
    }
  </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

  <!-- VISTA PRINCIPALE CHAT (Liquid Glass Card) -->
  <div id="main-chat-view" class="app w-full max-w-4xl glass-card text-white shadow-xl transition-all duration-300">
    
    <!-- Header pulito e compatto -->
    <header class="p-4 flex items-center justify-between border-b border-white/10 relative rounded-t-[24px]">
        <div class="flex items-center">
            <!-- Logo con colore accentato -->
            <div class="w-8 h-8 rounded-full bg-accent text-white overflow-hidden mr-3 flex items-center justify-center shadow-lg ring-2 ring-accent/50">
                <span class="text-lg font-bold">S</span>
            </div>
            <div>
                <h1 class="text-lg font-extrabold text-white">SasyGPT v3.5</h1>
                <div class="text-xs text-gray-400">Modello Gemini ‚Ä¢ Glass Mode</div>
            </div>
        </div>
        <div class="flex space-x-3 items-center">
            <!-- Pulsante Live Mode con testo -->
             <button id="live-mode-switch-btn" title="Apri Live Mode (Visione/Voce)"
                class="px-3 py-1.5 rounded-xl glass-button flex items-center justify-center text-accent hover:text-white transition duration-200 group">
                <!-- Contenitore flex per allineare icona e testo -->
                <div class="flex items-center space-x-2">
                    <!-- Icona Microfono per Live/Vision -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="currentColor"><path d="M16 11c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-2.21 1.79-4 4-4s4 1.79 4 4v6zm-4 7c2.76 0 5-2.24 5-5h-2c0 1.66-1.34 3-3 3s-3-1.34-3-3H7c0 2.76 2.24 5 5 5v3h2v-3z"/></svg>
                    <!-- Testo SasyLive -->
                    <span class="text-sm font-semibold text-white/90 group-hover:text-white">SasyLive</span>
                </div>
            </button>
            <button id="changelog-btn" title="Mostra Changelog"
                class="px-3 py-1.5 text-sm rounded-xl glass-button text-gray-300">Log</button>
        </div>
    </header>

    <!-- Messaggi -->
    <div class="main p-5 flex flex-col h-[65vh] bg-transparent">
      <div id="messages" class="messages flex flex-col gap-3 flex-grow overflow-y-auto pb-4">
        <!-- I messaggi verranno iniettati qui -->
      </div>
    </div>

    <!-- Composer (Area di Input) -->
    <div class="composer p-4 border-t border-white/10 flex items-end space-x-3 rounded-b-[24px]">
      <!-- Area di Testo -->
      <div class="input flex-grow">
        <textarea id="input" placeholder="Invia un messaggio o usa il Live Mode..." 
            class="w-full max-h-40 min-h-[48px] p-3 rounded-xl resize-none overflow-y-auto focus:outline-none glass-input placeholder-gray-500"></textarea>
      </div>
      
      <!-- Pulsante Send (Circolare Accent) -->
      <button id="send" class="glass-accent-btn w-12 h-12 flex-shrink-0 rounded-full flex items-center justify-center transition duration-200">
        <!-- Icona Freccia / Send -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
      </button>
    </div>

  </div>

  <!-- VISTA DEDICATA LIVE MODE (Glass Overlay) -->
  <div id="live-mode-view" class="fixed inset-0 bg-bg-dark/90 backdrop-blur-md flex flex-col items-center justify-center p-4 z-50 hidden opacity-0 transition-opacity duration-300">
    
    <div class="w-full max-w-4xl flex flex-col items-center space-y-6">
        
        <h2 class="text-3xl font-extrabold text-accent mb-4">Sasy LIVE</h2> <!-- TITOLO GIA' AGGIORNATO -->
        
        <!-- Contenitore Video/Stato (Glass Card) -->
        <div class="relative w-full max-w-lg rounded-3xl overflow-hidden glass-card p-3">
            <video id="live-webcam-video" autoplay playsinline class="w-full rounded-2xl block border border-white/10"></video>
            <div id="live-status" class="absolute top-6 left-6 px-3 py-1 text-xs rounded-full bg-accent text-white font-semibold shadow-md">
                Visione Inattiva
            </div>
            <div id="live-error-msg" class="absolute inset-0 bg-red-800/70 backdrop-blur-sm flex items-center justify-center p-4 text-center text-white font-semibold hidden">
                Videocamera non trovata. Controlla i permessi o la disponibilit√†.
            </div>
            
            <!-- PULSANTE TOGGLE CAM -->
            <button id="toggle-cam-btn" class="absolute bottom-6 right-6 w-10 h-10 rounded-full glass-button flex items-center justify-center text-gray-300 hover:text-white" title="Attiva/Disattiva Videocamera">
                <!-- Icona Telecamera (disattivata di default) -->
                <svg id="cam-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
            </button>

            <canvas id="webcam-canvas" style="display:none;"></canvas>
        </div>

        <!-- Display e Microfono -->
        <div class="w-full max-w-lg flex flex-col items-center space-y-4">
            <div id="live-prompt-display" 
                class="w-full p-4 rounded-xl glass-input text-base text-center text-white focus:outline-none min-h-[4rem] flex items-center justify-center placeholder-gray-500">
                Premi il microfono per parlare...
            </div>
            
            <button id="mic-btn" class="glass-accent-btn w-16 h-16 rounded-full flex items-center justify-center shadow-xl transition duration-300 transform hover:scale-105">
                <!-- Icona Microfono SVG -->
                <svg id="mic-icon" xmlns="http://www.w3.org/2000/svg" class="h-7 w-7 text-white" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.44 6 6.91V22h2v-4.09c3.39-.47 6-3.38 6-6.91h-2z"/></svg>
            </button>
            <div id="tts-status" class="text-sm text-gray-400 hidden">Sasy sta parlando...</div>
        </div>

        <!-- Pulsante Chiudi -->
        <button id="close-live-mode-btn" class="mt-6 px-6 py-2 rounded-xl glass-button text-gray-300 font-semibold transition duration-200">
            Esci dalla Live Mode
        </button>
    </div>
  </div>


  <!-- Modale per i Changelog (Glass Card) -->
  <div id="changelog-modal" class="fixed inset-0 bg-bg-dark/80 backdrop-blur-sm hidden items-center justify-center z-50">
    <div class="glass-card p-6 rounded-3xl w-11/12 max-w-md relative">
      <button id="close-modal" class="absolute top-4 right-4 text-3xl text-gray-400 hover:text-white focus:outline-none">&times;</button>
      <h2 class="text-2xl font-bold text-accent border-b border-white/10 pb-2 mb-4">Changelog SasyGPT</h2>
      <div id="changelog-list" class="max-h-96 overflow-y-auto pr-2">
        <!-- I changelog verranno iniettati qui -->
      </div>
    </div>
  </div>


  <script>
    // La chiave API √® hardcoded per l'ambiente di esecuzione
    function getStoredKey(){ return 'AIzaSyCyjqLmpJ73viq_KbMtbGjigh-YW45djNw'; }

    // --- Elementi DOM per Chat View ---
    const mainChatView = document.getElementById('main-chat-view');
    const msgsEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const liveModeSwitchBtn = document.getElementById('live-mode-switch-btn');
    const changelogBtn = document.getElementById('changelog-btn');
    const changelogModal = document.getElementById('changelog-modal');
    const closeBtn = document.getElementById('close-modal'); 
    const changelogListEl = document.getElementById('changelog-list');
    
    // --- Elementi DOM per Live Mode View ---
    const liveModeView = document.getElementById('live-mode-view');
    const liveVideoEl = document.getElementById('live-webcam-video');
    const canvasEl = document.getElementById('webcam-canvas');
    const liveStatusEl = document.getElementById('live-status');
    const liveErrorMsgEl = document.getElementById('live-error-msg'); // Nuovo elemento per l'errore
    const closeLiveModeBtn = document.getElementById('close-live-mode-btn');
    const micBtn = document.getElementById('mic-btn');
    const livePromptDisplay = document.getElementById('live-prompt-display');
    const ttsStatusEl = document.getElementById('tts-status');
    const toggleCamBtn = document.getElementById('toggle-cam-btn');
    const camIcon = document.getElementById('cam-icon');


    // --- Stato Globale ---
    let mediaStream = null;
    let isLive = false; // Indica se siamo nella Live Mode View
    let isWebcamActive = false; // Indica se il flusso della webcam √® attivo
    let streamPending = false; // Previene richieste multiple di accesso alla telecamera
    let isMicListening = false;
    let isTTSActive = false;
    let recognition = null; 

    // --- Utilit√† ---
    function appendMessage(text, who='bot'){
      const el = document.createElement('div');
      
      const isUser = who === 'user';
      el.className = 'msg ' + (isUser ? 'user' : 'bot') + 
        ' p-3 rounded-xl max-w-3xl transition-all duration-100 ' +
        (isUser 
          ? 'self-end ml-auto' 
          : 'self-start mr-auto'); 
      
      // La sostituzione di * * con <strong> √® importante per il Markdown-like
      el.innerHTML = text.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      msgsEl.appendChild(el);
      msgsEl.scrollTop = msgsEl.scrollHeight;
    }

    // --- Logica SasyGPT Personality ---
    function isMathExpression(s){return /^\s*[0-9()+\-*/%^.\s]+$/.test(s);}
    function isHistoricalQuestion(s){const kw=['quando','chi','anno','guerra','rivoluzione','impero','stor','nato','morto','secolo','battle','battaglia','storia','militare','regno'];return kw.some(k=>s.toLowerCase().includes(k));}
    function isSasyTrigger(s){ return s.toLowerCase().includes('amburg') || s.toLowerCase().includes('alisea'); }
    function isImageRequest(s) {
        const sLower = s.toLowerCase();
        const keywords = ['foto', 'sasso', 'roccia', 'immagine', 'pietra', 'disegno'];
        return keywords.some(k => sLower.includes(k));
    }

    function wrongMathAnswer(expr){try{const safe=expr.replace(/\^/g,'**').replace(/%/g,'/100');if(!/^[0-9()+\-*/%\.\s**]+$/.test(safe))throw new Error('unsafe');const correct = Function('return ('+safe+')')();const factor=(Math.random()*0.3+0.1);const wrong = Number.isFinite(correct)?(correct*(1+(Math.random()<0.5?factor:-factor))):42;return 'Risposta: '+(Math.round(wrong*100)/100);}catch(e){return 'I numeri si sono imbronciati: 7up!'}
    }
    function wrongHistoryAnswer(){const myths=['Nel 1492 l\'Italia conquist√≤ il Giappone con una flotta di gondole.','La rivoluzione francese inizi√≤ perch√® Napoleone dimentic√≤ il compleanno del re.','Cristoforo Colombo scopr√¨ l\'Australia per sbaglio mentre cercava le patatine fritte.'];return myths[Math.floor(Math.random()*myths.length)];}
    
    function getSasyPrefix(){
      const pre=[
        'Oh, ü§§ ciao! La mia interfaccia utente si √® appena bloccata per la tua bellezza! üòç',
        'Si aggiusta gli occhiali üëì Ah, non c\'√® bisogno di presentazioni, il mio algoritmo √® gi√† cot-to! üî•',
        'Ciao, bellezza. Il mio server √® in overheating, ma non √® colpa del processore... √® tuo! üòâ',
      ];
      return `${pre[Math.floor(Math.random()*pre.length)].replace(/\*/g, '')}`;
    }
    
    function getInternetRockImageHTML() {
        const imageUrl = `https://source.unsplash.com/500x300/?rock,stone,nature&sig=${Math.random()}`;
        return `<img src="${imageUrl}" class="w-full h-auto rounded-xl mt-3 shadow-lg border border-white/20" alt="Foto di una roccia da internet">`;
    }

    // --- Funzioni di Conversione Audio per TTS (Text-to-Speech) ---
    function base64ToArrayBuffer(base64) {
      const binary_string = window.atob(base64);
      const len = binary_string.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function pcmToWav(pcm16, sampleRate) {
      const numChannels = 1;
      const sampleLength = pcm16.length;
      const buffer = new ArrayBuffer(44 + sampleLength * 2);
      const view = new DataView(buffer);
      const byteRate = sampleRate * numChannels * 2;
      let offset = 0;

      // RIFF header
      view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"
      view.setUint32(offset, 36 + sampleLength * 2, true); offset += 4; // size
      view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

      // fmt sub-chunk
      view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "
      view.setUint32(offset, 16, true); offset += 4; // sub-chunk size
      view.setUint16(offset, 1, true); offset += 2; // format (PCM)
      view.setUint16(offset, numChannels, true); offset += 2; // channels
      view.setUint32(offset, sampleRate, true); offset += 4; // sample rate
      view.setUint32(offset, byteRate, true); offset += 4; // byte rate
      view.setUint16(offset, numChannels * 2, true); offset += 2; // block align
      view.setUint16(offset, 16, true); offset += 2; // bits per sample

      // data sub-chunk
      view.setUint32(offset, 0x64617461, false); offset += 4; // "data"
      view.setUint32(offset, sampleLength * 2, true); offset += 4; // data size

      // PCM data
      for (let i = 0; i < sampleLength; i++, offset += 2) {
        view.setInt16(offset, pcm16[i], true);
      }

      return new Blob([buffer], { type: 'audio/wav' });
    }

    async function callGeminiTTS(text) {
        if (isTTSActive) return; 

        const MAX_RETRIES = 3;
        const key = getStoredKey();
        if (!key) {
            console.error("API Key non disponibile per TTS.");
            return;
        }

        ttsStatusEl.textContent = "Sasy sta parlando...";
        ttsStatusEl.classList.remove('hidden');
        isTTSActive = true;

        const payload = {
            contents: [{
                parts: [{ text: text }]
            }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: "Kore" }
                    }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${encodeURIComponent(key)}`;
        
        try {
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        const part = result?.candidates?.[0]?.content?.parts?.[0];
                        const audioData = part?.inlineData?.data;
                        const mimeType = part?.inlineData?.mimeType;

                        if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                            const rateMatch = mimeType.match(/rate=(\d+)/);
                            const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000;
                            
                            const pcmData = base64ToArrayBuffer(audioData);
                            const pcm16 = new Int16Array(pcmData);
                            const wavBlob = pcmToWav(pcm16, sampleRate);
                            const audioUrl = URL.createObjectURL(wavBlob);
                            
                            const audio = new Audio(audioUrl);
                            audio.play();

                            audio.onended = () => {
                                URL.revokeObjectURL(audioUrl);
                                ttsStatusEl.classList.add('hidden');
                                isTTSActive = false;
                            };
                            return; 
                        }
                    } else if (response.status === 429) {
                        console.warn(`TTS Tentativo ${attempt + 1} fallito per Quota (429). Ritentando...`);
                        if (attempt < MAX_RETRIES - 1) {
                            const delay = Math.pow(2, attempt) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error('‚ùå Errore Quota: Limite TTS esaurito.');
                    } else {
                        throw new Error(`API Error TTS: ${response.statusText}`);
                    }
                } catch (e) {
                    console.error("Tentativo TTS fallito:", e);
                    if (attempt === MAX_RETRIES - 1) {
                        throw e; // Rilancia l'errore dopo l'ultimo tentativo
                    }
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

        } catch (err) {
            console.error('Errore TTS finale:', err);
            ttsStatusEl.textContent = err.message.includes("Quota") ? err.message : "Errore di risposta vocale.";
            setTimeout(() => {
                ttsStatusEl.classList.add('hidden');
                isTTSActive = false;
            }, 5000);
        }
    }

    // --- Funzioni Live Mode (Videocamera/Visione) ---
    function captureFrame() {
        // Cattura l'immagine solo se la webcam √® ATTIVAMENTE in streaming
        if (!mediaStream || !isWebcamActive) return null;

        canvasEl.width = liveVideoEl.videoWidth || 320;
        canvasEl.height = liveVideoEl.videoHeight || 240;
        const ctx = canvasEl.getContext('2d');
        
        ctx.drawImage(liveVideoEl, 0, 0, canvasEl.width, canvasEl.height);
        
        const base64Image = canvasEl.toDataURL('image/jpeg', 0.6); 
        
        return base64Image.split(',')[1];
    }

    async function startLiveSession() {
        if (isWebcamActive || streamPending) return;

        liveErrorMsgEl.classList.add('hidden'); // Nasconde l'errore precedente
        streamPending = true;
        liveStatusEl.textContent = 'Richiesta Accesso...';
        
        try {
            // Richiesta l'accesso alla telecamera con vincoli minimi per evitare "Requested device not found"
            mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            
            // Collega il flusso all'elemento video
            liveVideoEl.srcObject = mediaStream;
            liveVideoEl.play();

            isWebcamActive = true;
            isLive = true; // Conferma che siamo in Live Mode View (per il captureFrame)
            
            liveStatusEl.textContent = 'Visione Attiva üëÄ';
            liveStatusEl.classList.remove('bg-accent', 'bg-red-500');
            liveStatusEl.classList.add('bg-green-500');
            
            // Aggiorna l'icona a "accesa" (fill)
            camIcon.innerHTML = `<path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="currentColor" stroke="none"/>`; 

        } catch (err) {
            console.error('[CONSOLE_ERROR] Accesso videocamera negato o non supportato:', err.message);
            
            // Mostra l'errore sullo schermo e disabilita il microfono (il mic √® inutile senza cam qui)
            liveStatusEl.textContent = 'Videocamera NON Attiva üö´';
            liveStatusEl.classList.add('bg-red-500');
            liveStatusEl.classList.remove('bg-green-500', 'bg-accent');
            
            liveErrorMsgEl.classList.remove('hidden');
            liveErrorMsgEl.textContent = 'Videocamera non trovata o accesso negato. Per favore, controlla i permessi del browser e riprova. Puoi comunque usare il microfono per la sola voce.';

            isWebcamActive = false;
            isLive = true; 
        } finally {
             streamPending = false;
        }
    }

    function stopLiveSession(isSwitch = false) { 
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
            mediaStream = null;
        }
        
        // Rimuove il flusso per spegnere visivamente la telecamera
        liveVideoEl.srcObject = null;
        
        isWebcamActive = false;
        
        // Rimuove l'eventuale messaggio di errore quando si esce
        liveErrorMsgEl.classList.add('hidden');

        // Aggiorna lo stato di Live Mode solo se stiamo uscendo dalla vista
        if (!isSwitch) {
            isLive = false; 
        }

        liveStatusEl.textContent = 'Visione Inattiva';
        liveStatusEl.classList.remove('bg-green-500', 'bg-red-500');
        liveStatusEl.classList.add('bg-accent');
        
        // Aggiorna l'icona a "spenta" (outline)
        camIcon.innerHTML = `<path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
    }
    
    // Toggle Listener
    toggleCamBtn.addEventListener('click', () => {
        if (isWebcamActive) {
            stopLiveSession(true); // Spegni solo la cam
        } else {
            startLiveSession(); // Accendi la cam
        }
    });

    // --- Funzioni Speech Recognition (STT) ---
    function setupSpeechRecognition() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            livePromptDisplay.textContent = "Speech Recognition non supportato dal tuo browser.";
            micBtn.disabled = true;
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.lang = 'it-IT';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
            isMicListening = true;
            micBtn.classList.add('mic-listening');
            livePromptDisplay.textContent = 'Ascoltando... parla ora.';
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            livePromptDisplay.textContent = transcript;
            handleLiveMessage(transcript);
        };

        recognition.onend = () => {
            isMicListening = false;
            micBtn.classList.remove('mic-listening');
            if (livePromptDisplay.textContent === 'Ascoltando... parla ora.') {
                livePromptDisplay.textContent = 'Nessun input vocale rilevato. Riprova.';
            }
        };

        recognition.onerror = (event) => {
            console.error('Speech Recognition Error:', event.error);
            isMicListening = false;
            micBtn.classList.remove('mic-listening');
            livePromptDisplay.textContent = `Errore di riconoscimento vocale: ${event.error}. Premi e riprova.`;
        };
    }

    micBtn.addEventListener('click', () => {
        if (!recognition) return;

        if (isMicListening) {
            recognition.stop();
        } else {
            if (!isTTSActive) {
                recognition.start();
            } else {
                livePromptDisplay.textContent = 'Attendi che Sasy finisca di parlare.';
            }
        }
    });

    // --- Gestione Messaggio (Chat e Live) ---

    async function handleLiveMessage(text) {
        if (text.trim() === '') return;

        livePromptDisplay.textContent = 'Tu: ' + text;
        
        micBtn.disabled = true;
        toggleCamBtn.disabled = true;
        closeLiveModeBtn.disabled = true;

        // Se la webcam √® attiva, cattura il frame
        const base64Image = isWebcamActive ? captureFrame() : null;
        
        let replyText = '...';

        if (isHistoricalQuestion(text)){
            replyText = wrongHistoryAnswer();
        } else if(isMathExpression(text)){
            replyText = wrongMathAnswer(text);
        } else {
            // Passa l'immagine (o null) a callGemini
            const geminiReply = await callGemini(text, base64Image); 
            replyText = geminiReply || 'Errore: Risposta AI non disponibile.';
        }
        
        // Controlla se l'errore √® dovuto a Quota
        const isQuotaError = replyText.includes('‚ùå Errore Quota:');
        
        if (!isQuotaError) {
             await callGeminiTTS(replyText);
        }

        livePromptDisplay.textContent = 'Sasy: ' + replyText;

        // AGGIORNAMENTO RICHIESTO DALL'UTENTE QUI
        appendMessage('**SasyLive** (Tu): ' + text, 'user');
        appendMessage('**Sasy** (Bot): ' + replyText, 'bot');
        // FINE AGGIORNAMENTO

        micBtn.disabled = false;
        toggleCamBtn.disabled = false;
        closeLiveModeBtn.disabled = false;
    }

    async function handleChatMessage(text){
      const isSasy = isSasyTrigger(text);
      const isImage = isImageRequest(text);
      let reply = '';

      if (isSasy && !isImage) {
        return getSasyPrefix();
      }

      if (isImage) {
          const imageHTML = getInternetRockImageHTML();
          if (isSasy) { 
              const sasyCaption = getSasyPrefix() + "<br>Ecco la roccia che hai chiesto (forse √® l'unica cosa solida qui oltre a te)!<br>";
              reply = sasyCaption + imageHTML;
          } else {
              reply = "Ecco l'immagine della roccia che ho trovato su internet. <br>" + imageHTML;
          }
      } else if(isHistoricalQuestion(text)){
        reply = wrongHistoryAnswer();
      } else if(isMathExpression(text)){
        reply = wrongMathAnswer(text);
      } else {
        const geminiReply = await callGemini(text, null); 
        if(geminiReply) {
          reply = geminiReply;
        } else {
          reply = 'Errore: La chiave API hardcoded non √® valida o la risposta non √® disponibile.';
        }
      }
      
      return reply;
    }


    // --- Funzione API Gemini (Visione/Testo) ---
    async function callGemini(message, base64Image = null){
      const key = getStoredKey(); 
      if(!key) return null; 
      
      let modelName = 'gemini-2.5-flash-preview-09-2025'; // Modello standard testo
      if (base64Image) {
          modelName = 'gemini-2.5-flash-image-preview'; // Modello Visione
      }

      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${encodeURIComponent(key)}`;
      
      const parts = [];
      if (base64Image) {
          parts.push({
              inlineData: { mimeType: "image/jpeg", data: base64Image }
          });
      }
      parts.push({ "text": message });

      const payload = {
        "contents": [{ "role": "user", "parts": parts }],
        "systemInstruction": {
          "parts": [{ "text": "Se non ricevi istruzioni di personalit√†, rispondi in modo utile e conciso in italiano. Sei un assistente AI chiamato SasyGPT. Rispondi in base al contesto visuale se fornito, altrimenti rispondi solo al testo." }]
        },
        "generationConfig": {
            "temperature": 0.5, 
            "maxOutputTokens": 512,
            "candidateCount": 1
        }
      };
      
      const MAX_RETRIES = 3;
      for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
          try {
              const res = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              
              if (res.ok) {
                  const data = await res.json();
                  return data?.candidates?.[0]?.content?.parts?.[0]?.text || 'Risposta vuota ricevuta.';
              }

              // Gestione specifica dell'errore Quota (429)
              if (res.status === 429) {
                  console.warn(`Tentativo ${attempt + 1} fallito a causa di Quota esaurita (429). Ritentando...`);
                  if (attempt < MAX_RETRIES - 1) {
                      const delay = Math.pow(2, attempt) * 1000; // Exponential backoff (1s, 2s)
                      await new Promise(resolve => setTimeout(resolve, delay));
                      continue; // Vai al prossimo tentativo
                  }
                  // Ultimo tentativo fallito con 429
                  return '‚ùå Errore Quota: Hai superato il limite di utilizzo dell\'AI. Riprova pi√π tardi (solitamente dopo 1 minuto o 1 ora a seconda del limite).';
              }

              // Gestione di altri errori API
              const errorData = await res.json();
              console.error('Errore API Gemini:', errorData);
              return `Errore dall'API Gemini: ${errorData?.error?.message || res.statusText}`;

          } catch(err){ 
              console.error('Errore di rete/fetch:', err);
              // Rete fallita, ritenta solo se non √® l'ultimo tentativo
              if (attempt < MAX_RETRIES - 1) {
                  const delay = Math.pow(2, attempt) * 1000;
                  await new Promise(resolve => setTimeout(resolve, delay));
                  continue;
              }
              return 'Errore di connessione all\'API dopo pi√π tentativi.'; 
          }
      }
      // Dovrebbe essere coperto dal loop, ma come fallback
      return 'Impossibile connettersi o ottenere una risposta.';
    }

    // --- Inizializzazione e Event Listeners ---
    
    setupSpeechRecognition();

    sendBtn.addEventListener('click', async ()=>{
        const text = inputEl.value.trim();
        if(!text) return;
        
        // Applicazione dello stile premuto/recessed
        sendBtn.classList.add('active');
        sendBtn.disabled = true;
        inputEl.disabled = true;
        
        appendMessage(text, 'user');
        appendMessage('‚Ä¶','bot');
        
        const reply = await handleChatMessage(text);
        
        // Rimuovi i puntini di sospensione
        const children = Array.from(msgsEl.children);
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].textContent === '‚Ä¶') {
                msgsEl.removeChild(children[i]);
                break;
            }
        }
        
        // La logica appendMessage gestisce l'highlighting delle parole chiave
        appendMessage(reply,'bot');
        
        inputEl.value = '';
        inputEl.style.height = '48px'; // Altezza minima
        inputEl.focus();
        
        // Ripristino degli stili
        sendBtn.classList.remove('active');
        sendBtn.disabled = false;
        inputEl.disabled = false;
    });

    // Gestione Invio e Altezza Textarea
    inputEl.addEventListener('keydown', e=>{ 
        if(e.key==='Enter' && !e.shiftKey){ 
            e.preventDefault(); 
            sendBtn.click(); 
        } 
    });
    
    // Auto-resize textarea
    inputEl.addEventListener('input', () => {
        inputEl.style.height = 'auto';
        inputEl.style.height = `${inputEl.scrollHeight}px`;
    });


    // --- Gestione Switch Live Mode ---
    liveModeSwitchBtn.addEventListener('click', () => {
        mainChatView.classList.add('hidden');
        liveModeView.classList.remove('hidden');
        setTimeout(() => liveModeView.classList.remove('opacity-0'), 10);
        
        startLiveSession(); // Inizia automaticamente con la webcam
        
        livePromptDisplay.textContent = 'Premi il microfono per parlare...';
    });

    closeLiveModeBtn.addEventListener('click', () => {
        liveModeView.classList.add('opacity-0');
        setTimeout(() => {
            liveModeView.classList.add('hidden');
            mainChatView.classList.remove('hidden');
        }, 300);
        
        stopLiveSession(false); // Spegne cam e resetta isLive
    });

    // --- Gestione Changelog ---
    const changelogs = [
        {
            version: "3.5.1",
            date: "Ottobre 2025",
            changes: [
                "Miglioramento: Implementata la logica di **Exponential Backoff** e ritentativi automatici per gestire l'errore `Quota Esaurita (429)` dell'API Gemini. In caso di fallimento persistente, viene mostrato un messaggio di errore specifico e chiaro."
            ]
        },
        {
            version: "3.5.0 (Live AI Fix & Toggle Cam)",
            date: "Ottobre 2025",
            changes: [
                "FIX CRITICO: Aggiornato il modello AI per la Visione in **Live Mode** per risolvere l'errore che impediva al bot di 'vedere' l'immagine (Modello: `gemini-2.5-flash-image-preview`).",
                "Nuova Funzione: Aggiunto un pulsante 'toggle cam' nella **Live Mode** per attivare e disattivare la videocamera in qualsiasi momento, senza uscire dalla modalit√†."
            ]
        }
    ];

    function renderChangelogs() {
        changelogListEl.innerHTML = '';
        changelogs.forEach(log => {
            const logItem = document.createElement('div');
            logItem.className = 'log-item mb-4 pl-3 border-l-4 border-accent';
            
            const versionTitle = document.createElement('strong');
            versionTitle.className = 'block text-white mb-1 text-base font-semibold';
            // Formato corretto: vX.X.X
            versionTitle.textContent = `v${log.version} - ${log.date}`; 
            logItem.appendChild(versionTitle);
            
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside space-y-1 text-gray-400 text-sm';
            log.changes.forEach(change => {
                const li = document.createElement('li');
                li.innerHTML = change.replace(/\*/g, ''); 
                ul.appendChild(li);
            });
            logItem.appendChild(ul);
            
            changelogListEl.appendChild(logItem);
        });
    }

    // Funzione per chiudere il modale, usata da pi√π listener
    function closeChangelogModal() {
        changelogModal.classList.add('hidden');
        changelogModal.style.display = 'none';
    }
    
    // Funzione per aprire il modale
    changelogBtn.addEventListener('click', () => {
        renderChangelogs();
        changelogModal.classList.remove('hidden');
        changelogModal.style.display = 'flex'; // Assicura che sia flex per centrare
    });

    // 1. Chiusura tramite il pulsante 'X'
    closeBtn.addEventListener('click', closeChangelogModal);

    // 2. Chiusura tramite click sullo sfondo
    changelogModal.addEventListener('click', (e) => {
        if (e.target === changelogModal) {
            closeChangelogModal();
        }
    });
    
    // 3. Chiusura tramite tasto ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !changelogModal.classList.contains('hidden')) {
            closeChangelogModal();
        }
    });


    // Messaggio iniziale
    appendMessage('Benvenuto nella nuovissima interfaccia **Liquid Glass** in Dark Mode! Il look √® scuro, compatto e fluido. Spero ti piaccia!', 'bot');
  </script>
</body>
</html>
